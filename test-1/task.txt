Задание #1

Основное задание:

Нужно написать небольшое API и клиент для него на Golang.

API будет содержать 2 метода. Оба метода делают одно и то же, но один должен работать через unary GRPC, а второй через streaming.

Сервер при старте должен считывать данные из приложенного CSV файла. Файл содержит пары: префикс номера телефона -> MCCMNC код(ы) оператора, которому принадлежит этот префикс.

Задача методов API: принять на вход полный номер телефона, максимально быстро найти наиболее полный (длинный) префикс, которому соответствует этот номер, и вернуть в ответе MCCMNC код для этого префикса, если кодов было несколько, нужно вернуть только первый.

Взаимодействие между сервером и клиентом должно быть защищено с помощью mutual TLS (т.е. обе стороны проверяют сертификаты друг друга)

Этапы:
1. Сгенерировать Root CA self-signed сертификат, им подписать еще два сертификата: клиентский и серверный. Можно сделать готовыми инструментами (cfssl, openssl, etc.), можно написать для этого команду на Golang (все необходимые инструменты есть в стандартной библиотеке) - как больше нравится
2. Написать сервер и API, реализующее два метода, описанных выше
3. Написать клиентское приложение, которое принимает на вход номер телефона и вызывает один из методов (unary или streaming), ответ выводит в stdout.

Можно оформить это в виде одного проекта, который выполняет команды: одна на запуск сервера, вторая на запуск клиента и выполнение поиска MCCMNC кода. 
Собрать можно, например, с помощью пакета Cobra.

Т.е. предполагается, что в итоге будет компилироваться бинарник, для которого можно выполнить как минимум пару команд:

$ ./testapp server run --port 8080

$ ./testapp client search 79601234567 --host localhost:8080 --type streaming

Команды сформированы для примера, синтаксис может быть другим. Для клиента должна быть возможность указать тип общения с сервером (unary или streaming).
Финальная структура на усмотрение исполнителя (сколько бинарников, формат команд и т.п.).
С файлами конфигурации или вспомогательными параметрами возиться не обязательно - если хотите, зашивайте все прямо в код (путь к исходным данным, пути к сертифкатам, порты и т.п.)

При генерации сертификатов и написании кода следует учитывать:
- необходима максимальная производительность (если нужно, платим памятью за скорость)
- сервер должен правильно работать при большом количестве одновременных запросов; в том числе считаем, что один клиент может делать сразу много паралельных запросов (имплементировать распараллеливание на стороне клиента не нужно)
- при поиске считаем, что список кодов на сервере может меняться динамически в процессе его работы (имплементировать методы для изменения не нужно)


Дополнительное задание (делать по желанию):

Сделать авторизацию при запросах к серверу с помощью GRPC interceptor'ов. Зашить прямо в код сервера один токен (просто рандомную строку). Если при запросе передан этот токен - выполнять метод, если не передан (или передан неправильный) - возвращать ошибку Unauthorized. Можно сделать указание токена параметром команд.